<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Zone:X - Sonic Starship</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
<script src="three.min.js"></script>

		<div id="container"></div>

		<script id="vertexShader" type="x-shader/x-vertex">

			varying vec2 vUv;
        		uniform vec2 coords;
       			uniform vec2 resolution;
       			uniform float time;

			void main()	{

				vUv = uv;
				gl_Position = vec4( position, 1.0 );
			}
		</script>

		<script id="fragmentShader" type="x-shader/x-fragment">

            varying vec2 vUv;
            uniform vec2 coords;
               uniform vec2 resolution;
            uniform int colorCombo;
            uniform float time;
            uniform float time2dance;
            float zin(float x){return -sin(x);}
            float coz(float x){return -cos(x);}
                      const float gr=-cos(216.)/-cos(612.)-1.;
          vec3 heart(vec2 g, vec2 t){
              g.x-=.5;
              g.y*=-1.;
              vec2 z=g.xy;
          vec3 h=vec3(0.);
              for (int f=0;f<20;f+=1)if(abs(z.y)>10.)h=vec3(0.);
              else {z=vec2(((z.x*z.x-z.y*z.y)-g.x+t.x),(2.0*z.x*z.y-g.y+t.y*4.));//mandelbrot loop factored into real and imaginary components from z<=z^2-g
                h+=vec3(z.x*z.y,z.x,z.y)/7.;}
          return h;
          }
          vec3 face(vec2 g, vec2 t){
          float l = 1.;
          g*=2.;
          vec2 z=g.xy;
          if(g.x*g.x+g.y*g.y<40.)for (int f=0;f<21;f+=1)if(abs(z.y)>19.&&(f==1||f>3)){
              if (f==1){l=1.;break;}
              l=1.-length(z)/40.;//clouds and face
              break;}
          else{
              z=vec2(-1./(z.x*z.x-z.y*z.y-g.x),2.0*z.x*z.y-g.y);
              l=abs(z.y)*6.;//smooths middle horn, removes some clouds
              if(z.x>-.1)l=z.x*50.;}//face with closed small holes
          return vec3(clamp(1.-l,0.,1.));
          }

           vec3 man(vec2 p,vec2 t) {
               p*=-2.;
               vec2 s = p;
               float d = 1.0, l;
               float flip=-t.x;
               if (flip<0.) p = -p;
               if (abs(p.x*p.x+p.y*p.y)<2.0)for (int t = 0; t < 30; t++) {
                       s = vec2(((s.x * s.x - s.y * s.y) +flip* p.x), (s.x * s.y + flip*p.y));
                       s.x = 1./pow(s.x,flip)*sign(s.x*flip);
                 l = length(s);
                 d += l/25.;
                   if (l >20.0&&t!=0)return vec3(1.);}
                   return vec3(0.);
           }


           vec3 eagle(vec2 p,vec2 t) {
           p*=10.;
               vec2 s = p;
               float d = 0.0, l;
               float flip=-t.x;
               if (flip<0.) p = -p;
               if(abs(6.*p.x*p.x+p.y*p.y*2.)<700.0)
               for (int i = 0; i < 30; i++) {
                   s=vec2(-(s.x * s.x - s.y * s.y) +flip* p.x, (s.x * s.y + t.y*p.y));
                  /* if(b<=.5 ||rate == 0.)
                       s.x = 1./s.x;
                   else*/
                   s.x = 1./pow(s.x,flip)*sign(s.x*flip);
                     s.y = s.x*s.y;
                   l = length(s);
                   d +=2.;
                   if (l >(20.0) ) if( float(i)>3.&&float(i)>3.)
                       return vec3(1.-sin(d * 0.003)-.5,1.- sin(d * 0.9)-.5,1.- sin(d * 0.1)-.5)*3.;}
               return vec3(.0);}
           vec3 lion(vec2 p,vec2 t) {
               p*=-3.;
             vec2 s = -p;

          float d = 0.0, l;
          
          float flip=t.x;
          if (flip<0.) p = -p;
          if(p.x*p.x*1.+p.y*p.y*2.<21.)
          for (int t = 0; t < 30; t++) {
              s = vec2(((s.x * s.x - s.y * s.y) +flip* p.x), (2.0* s.x * s.y + flip*p.y));
              s/=2.;
              s.x = pow(s.x,flip)*sign(s.x*flip);
              l = length(s);
              d += l/40.;
          
              if (l >14.0 &&float(t)  >2.)
                  return vec3(-sin(d +1.),-sin(d +1.8),-sin(d+3.));
               ;  // return vec3(0.);
          }
          return vec3(.0);
          }
       vec3 ox(vec2 p,vec2 t) {
          p*=-2.;
             vec2 s = p;
             float d = 0.0, l;
               float flip=t.x;
               if (flip<0.) p = -p;
               if( (p.x+.25)*(p.x+.25)+p.y*p.y<1.||(p.x>0.&& p.x*p.x+p.y*p.y<7. ))
             for (int t = 0; t < 30; t++) {
               s = vec2(((s.x * s.x - s.y * s.y) +flip* p.x), (3.0* s.x * s.y + flip*p.y));
                 s.x = pow(s.x,flip)*sign(s.x*flip);
                 l = length(s);
               d += l/10.;
               if (l >14.0 )
                   if (float(t)  >2.)
                       return vec3(-sin(d +time*1./gr*2.),-sin(d +time*gr*2.),-sin(d *time*2.));
                                 // return vec3(0.);
             }
             return vec3(.0);
           }

          vec3 torso(vec2 g, vec2 t){
          float b = 0.;
          vec2 z=g.xy;
          if(g.x*g.x+g.y*g.y<40.)if (g.x>0.)for(int f=0;f<12;f+=1)if(abs(z.y)>52.&&f>4)b=abs(z.y)/77.;
          else{
              z=2.*vec2(-1./(z.x*z.x-z.y*z.y-g.x),(2.0*z.x*z.y-g.y+t.y));
              z.x=sqrt(abs(z.x));}
          return vec3(b,b/2.5,0.);
          }
          vec3 musculature(vec2 g, vec2 t){
          float m=0.;
          g.x+=.54;
          vec2 z=g.xy;
          if(g.x>1.25&&abs(g.y)<2.5)for(int f=0;f<15;f+=1)if(abs(z.y)>15.&&f>7&&f!=15)m=abs(z.y)/25.;
          else {
              z=1.3*vec2(-1.5/((z.x*z.x-2.*z.y*z.y)-g.x),(1.9*z.x*z.y-1.87*g.y+t.y/4.));
              z.x=pow(abs(z.x),.57);}
          return vec3(m,m,m/2.);
          }
          vec3 robe(vec2 g, vec2 t){
          float r=0.;
          g.x+=.05;
          g.y/=1.14;
          vec2 z=g.xy;
          if(g.x>.5 &&abs(g.y)<1.)for(int f=0;f<70;f+=1)if(abs(z.y)>11.&&f>7)r=clamp(1.4-abs(g.x-2.3)
                          // *(1.-abs(g.y*g.x))-.07//(un)comment this line to toggle sleeves
                          ,0.,1.);
          else{
              z=1.1*vec2(-2./((z.x*z.x-1.8*z.y*z.y)-g.x),(3.*z.x*z.y-1.3*g.y+t.y));;
              z.x=pow(abs(z.x),.8);}
          return vec3(r);
          }
          vec3 legs(vec2 g, vec2 t){
          float b=0.;
          g/=2.;
          vec2 z=g.xy;
          if(g.x>.75&&g.x<1.7&&abs(g.y*g.x)<.54)for(int f=0;f<8;f+=1)if(abs(z.x)>52.&&f>1)b=abs(z.x)/70.;
          else{
              z=3.*vec2(-1./(z.x*z.x-z.y*z.y-g.x),77.*z.x*z.y-g.y+t.y);
              z.y=-1./z.y;}
          return vec3(b/2.,b,b/2.);
          }
        vec3 tol(vec2 f, vec2 coords){
                        
                        f+=coords.yx;
                        vec2 s=f;
                        for (int counter=0;counter<21;counter+=1)if(abs(s.y)<47.){
                            s=vec2(s.x*s.x*s.x  - 3.*s.x*s.y*s.y, -s.y*s.y*s.y+ 3.*s.x*s.x*s.y);//x**3
                            s.x=log(abs(s.x));
                            }
                        vec3 tol=vec3(s.y);
                        if(colorCombo==1) tol=vec3(s.y,s.x/10.,1.-s.x/12.);
                        else if(colorCombo==2) tol=vec3(s.y/100.,s.x/8.-s.y/s.x/7000.,1.-s.x/16.)/1.2;
                        else if(colorCombo==3)tol=vec3(s.y);
                        return clamp(tol,0.,1.);}
          vec3 body(vec2 p, vec2 t){return heart(p,t)+torso(p,t)+musculature(p,t)+robe(p,t)+legs(p,t);}

          vec3 manny(vec2 p, vec2 t){return body(p,t)+face(p,t);}

          vec2 spin(vec2 p,float time_){
          float pixelangle = -atan(p.y,p.x)-(time_)/6.+3.14/8.;
          float pixeldistance = pow((p.y*p.y+p.x*p.x),.5);
          vec2 pTiltCoord =-vec2(pixeldistance*-cos(pixelangle),pixeldistance*-sin(pixelangle));
          return pTiltCoord;
          }
          
          //function library: manny body legs robe musculature torso face lion ox man eagle heart anomalyze spin
          void main(){
           vec2 p=-((vUv.yx)-.5)/(resolution.xy/min(resolution.x,resolution.y))*11.;
              p.x+=.5;

          float rate = 7.;
          vec2 t =vec2(-sin(rate*time2dance)/50.,-sin(time2dance*(rate*gr)*3.)/30.);
          vec2 fl=vec2(-1.,-sin(time));//vec2(-sin(rate*time),-sin(time*(rate*gr)*3.));
          vec3 mny = manny(p,t);
          gl_FragColor=vec4(mny+
                   /* man(p-2.,fl)+body(p-2.,t*2.)+
                    eagle(p+1.,fl)+body(p+1.,vec2(0.))+
                    lion(p+vec2(-2.,2.),fl)+body(p+vec2(-2.,2.),vec2(0.))+
                    ox(p+vec2(1.,-1.),fl)+body(p+vec2(1.,-1.),vec2(0.))+ */
                    clamp(tol(p*time,vec2(coords))-mny*10.,.0,1.)
                    ,1.);}
              
        </script>
		<script>
		
	/*	
function hsv2rgb (var hsv) {
  // from HSV to RGB color vector
  hsv.yz = clamp (hsv[1],hsv[2], 0.0, 1.0);
  return hsv[2] * (1.0 + 0.63 * hsv[1]] * (-cos (2.0 * 3.14159 * (hsv[0]] + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));
}//^^^^^^above from https://shadertoy.fandom.com/wiki/Color_Processing^^^^^//modified by X
*/

		var pi = 3.14159
        
const starArms = 240;
var geometries = Array(starArms);
var meshes = Array(starArms);
var testar = Array(starArms);
var testarD = Array(starArms);
    var maxFreq = 0;
var mamp = -1000000;
	var averagedAmp =  0;
	
	var len=0;
	var spirray0 = Array(2000);
	var spirray1 = Array(2000);
	var spiregulator=0;
	var phase = 0;
function makeSpirograph()
    {
        		phase = phase % (pi*2);
        len = 0;
        linx= inputData.length;
        var adjConstant = 1./(spirafreq)*3.14*1.618;
        //linx*=440./pitc;
       // if (linx >1100)linx = 1100;
        for(var m = 0; m < linx/1.1; m++)
        {
            if ( inputData[m]!=0 || isFinite(inputData[m]) ) 
            {

                var samp = inputData[m];
                phase += adjConstant;//spira_pitch;
                spirray0[len]=-Math.sin(phase)*samp;
                spirray1[len]=-Math.cos(phase)*samp;
                len++;
            }
        }
       
        len -= 1;
        largest_loop = 0;
        spiregulator = 0;
        
            for(var f = 0; f<len; f++)
        {

            if (Math.abs(spirray0[f])>largest_loop)largest_loop =
                                                             Math.abs(spirray0[f]);
            if (Math.abs(spirray1[f])>largest_loop)largest_loop =
                                                        Math.abs(spirray1[f]);
        }
        spiregulator=largest_loop;//*on;

    }

    function spiral_compress()
    {
        maxFreq = 0;
        var freq = 0;
        max1 = -100000;
        min1 = 100000;
		 mamp = -1000000;
        for(var n = 0; n<starArms; n++){testar[n] = 0;testarD[n] = 1;}
    
        var b = -1000000;
z = dataArray;
	 averagedAmp =  0;
        for(var t=1; t<1024; t+=1)//n<fftSize1/4-100
        {
            var n =t;
            //if (fftSize1/4<t) n =Math.abs(t-var(t)/(var(fftSize1/4)));

averagedAmp += z[n];
        if ( z[n]>z[n-1] && z[n] > z[n+1] )
            {

                var   d = (-z[n-1]+z[n+1])/(z[n-1]+z[n+1]);

                var nAdj = n;
                if (Math.abs(d)<1.1) nAdj = n + d;           
                //if (Math.abs(nAdj-n) < 10)
                freq =((( audioX.sampleRate /10000.)*(nAdj))/1024)*10000;


                {
                    var g = Math.pow ( 2, (1/24.));
                    var aa = freq/440.0;
                    var note = Math.log(aa)/Math.log(g)+69*2;
                                           if (!onO)testar[(Math.round(note))%24] += Math.abs(z[n]);
                                           else{
                                               testar[n] = Math.abs(z[n]);
                                               testarD[n] = note;
                                               }

                }
            }
        }

averagedAmp/=1000.;
    };

var time = 0;
var time2dance = 0;

    var maxInt24 = 0;
    var maxWave = 0;
  //  for(var n = 0; n<audiBuffer.length; n++)
///b = abs(-sin(n/audiBuffer.length*(pi*2.)));

	var shrinking, moving;
	var coordX=0.;
	var coordY=0.;
	var part = {cx : {  value: 0 },};
	var trail = Array(1000);
		var cx = Array(1000);
				var cy = Array(1000);
						var pitchCol = Array(1000);
   var trailLoaded = false;
   var trailDepth = -1;
      var trailLength = 144;
      var d_x=0,d_y=0;
      var f = 0;
      
      

                      var xPerp= Array(1000);
                      var yPerp = Array(1000);
                      var angle=Array(1000);
                      var MIN_SAMPLES = 0;  // will be initialized when AudioContext is created.

var pitc = 1;
 var inputData;
var nullresult= 0;
var  jankedNotes=0;
var bufferSize = 1024;
var reset = 0;
var on;
var spirafreq=1;
var totalAMP;
    function  move()
    {
    totalAMP = 0.;
    if (!trailLoaded) {trailLoaded = true; for(var n = 0; n<trailLength; n++) trail[n] = part;xPerp[n]=0;yPerp[n]=0;angle[n]=0;cx[n]=0;cy[n]=0;}

      inputData = new Float32Array(bufferSize);
    
     analyser.getFloatTimeDomainData(inputData); // fill the Float32Array with data returned from getFloatTimeDomainData() 
		//var iD = Array(inputData.length);
		//for(var m = 0; m<inputData.length; m++) iD[m]=(inputData[m]);
		 var pb = -1;
        for(var b = 0; b<analyser.fftSize/2.; b++)totalAMP+=Math.abs(inputData[b]);
        if(totalAMP>1.)
       pb =    calculatePitch();
       pt = pb;
            if(pb>0){pb =Math.pow(sampleRate/pb,.5);}
       var volumeModifier = dataArray[0];
on = 1;
if (isFinite(pb) &&pb>0&& pb!=6.565706694547585 &&pb!=1) {spirafreq=pt;pitc =pb;reset =0;}
else if (reset>3){averagedAmp =0;on = 0;spirafreq=pt;reset++}
else reset++

			{
if (trailDepth<trailLength)trailDepth++;

        var magnitude=.1;

        radius = magnitude;

            var g = Math.pow ( 2, (1/24.0));
            var aa = pitc/440.0;
            var note = Math.log(aa)/Math.log(g)+49;
            var inc = 8;
            var t =  (note * 30+30*inc);
            angle = t%360;
            angle = -angle;
	var vo = new THREE.Color();
				b = vo.setHSL((angle+90)/360.,1.,.5);
                              pitchCol[f]  = new THREE.MeshBasicMaterial({
                                      color:vo,
                                      opacity: .54,
                                      transparent: true,
                                    });			     angle = ((angle-30+180)/360*2*pi);
           // angle = (maxInt24/24*2*pi);
            angle[f] = angle;

            //Colour pitchCol = Colour::fromHSV((angle-60)/360.,saturation,value,1.);
			

           d_x = -Math.sin(-angle)*(2.*averagedAmp)**.8787;
          d_y = -Math.cos(-angle)*(2.*averagedAmp)**.8787 ;
                          bx=coordX+d_x*.02*zoom;
                          by=coordY+d_y*.02*zoom;
                                                              
  if(isFinite(d_x)&&isFinite(d_y)){
    if(Math.abs(by*by)+Math.abs(bx*bx)<2.){coordX+=d_x*.02*zoom;
        coordY+=d_y*.02*zoom;}
    else{
        if (Math.abs(by*by)<2.){coordY+=d_y*.02*zoom;coordX/=1.01;}
        if (Math.abs(bx*bx)<2.){coordX+=d_x*.02*zoom;coordY/=1.01;}
  }}


         interpolationFactor = 10.;//timeDif*1./(callbackWait-1);
        if (interpolationFactor>30) interpolationFactor=30;
        else if (interpolationFactor<1) interpolationFactor=1;

           cx[f] = 0;
            cy[f] = 0;
                 xPerp[f] = -Math.sin(-angle+pi/2);
                yPerp[f] = -Math.cos(-angle+pi/2);
                trail[f].radii = radius/2;

                
			f++;
			if (f>=trailDepth)f=0;

        for(var n = 0; n < trailDepth; n++)
        {
            cx[n] += d_x;
            cy[n] += d_y;
            }

    }
}
    var onO=false;
    var rez = window.devicePixelRatio;
    window.addEventListener('keydown', function(event) {
    var x = parseInt(String.fromCharCode(event.which || event.keyCode));
    if (x==1){rez = window.devicePixelRatio ; renderer.setPixelRatio( rez);}
    else if (String.fromCharCode(event.which || event.keyCode)=="Ã€")
     {rez=window.devicePixelRatio*2.;renderer.setPixelRatio( rez);}
     else if (String.fromCharCode(event.which || event.keyCode)=="Q") uniforms[ "colorCombo" ].value = 1;
     else if (String.fromCharCode(event.which || event.keyCode)=="W")   uniforms[ "colorCombo" ].value = 2;
     else if (String.fromCharCode(event.which || event.keyCode)=="E") uniforms[ "colorCombo" ].value = 3;
     else if (String.fromCharCode(event.which || event.keyCode)=="O")
     {
         if (onO)onO=false;
         else onO = true;
         }
    }, false);
var material;
			var container;
			var camera, renderer;
var mesh;
var micTexture;
var analyser;
var source;
var dataArray;
startMic();
                       
                                     
var zoom=1.;
var trailGeom = Array(1000);
var materials = Array(1000);
var trailMeshes = Array(1000);
var materialShader;
var geometry;
var progress = true;
window.addEventListener('keydown', function(event) {
var x = parseInt(String.fromCharCode(event.which || event.keyCode));
//if (x>0)
				//renderer.setPixelRatio( window.devicePixelRatio /x);
}, false);



var uniforms;
			function init() {

				container = document.getElementById( 'container' );
				camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

				
				 geometry = new THREE.PlaneBufferGeometry( 2, 2 );


for (var r=0; r<starArms; r++) {

	var vo = new THREE.Color();
				b = vo.setHSL((r-10)%24/24.,1.,.5);
            material  = new THREE.MeshBasicMaterial( { color:vo});
            
var vertices = new Float32Array( [0,0,0,
0,0,0,
0,0,0
] );
geometries[r] = new THREE.BufferGeometry();
geometries[r].addAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );

            
meshes[r] = new THREE.Mesh(geometries[r] , material );

	}	

for (var r=0; r<trailLength; r++) {

 materials[r] = new THREE.MeshBasicMaterial( { color: 0x0000f0 } );
var vertices = new Float32Array( [0,0,0,
0,0,0,
0,0,0
] );

trailGeom[r] = new THREE.BufferGeometry();
trailGeom[r].addAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
trailMeshes[r] = new THREE.Mesh(trailGeom[r] , materials[r] );


	}	
uniforms = THREE.UniformsUtils.merge([
  	  THREE.UniformsLib.lights, 
  {
					micIn : {  value: null }, // float array (vec3)
        time: {value: 1.0 },
        colorCombo: {value: 1 },
        time2dance: {value: 1.0 },

        resolution: {value: new THREE.Vector2() },
        coords: {value: new THREE.Vector2() }
}
  ]);
      uniforms.resolution.value.x = window.innerWidth;
      uniforms.resolution.value.y = window.innerHeight;
      uniforms.coords.value.x = coordX;
      uniforms.coords.value.y = coordY;
				 materialShader = new THREE.ShaderMaterial( {
					uniforms: uniforms,
					vertexShader: document.getElementById( 'vertexShader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentShader' ).textContent
				} );
		
				renderer = new THREE.WebGLRenderer();




				renderer.setPixelRatio( window.devicePixelRatio);

				container.appendChild( renderer.domElement );
				onWindowResize();
				window.addEventListener( 'resize', onWindowResize, false );
			animate();
			}
			function onWindowResize() {

      uniforms.resolution.value.x = window.innerWidth;
      uniforms.resolution.value.y = window.innerHeight;
				renderer.setSize( window.innerWidth, window.innerHeight );
				
				


			}
			//
			
			//
			
		

			function animate( timestamp ) {
			
spiral_compress();

move();
            if (reset<3)makeSpirograph();
			var lineMat = new THREE.LineBasicMaterial( {
	color: 0xffffff,
	linewidth: 3,
	linecap: 'round', //ignored by WebGLRenderer
	linejoin:  'round' //ignored by WebGLRenderer
} );
			var point = new THREE.Geometry();
var porportion = window.innerHeight/ window.innerWidth;
if (reset<3)for (var r= 0; r < len; r ++) {
                var tx = spirray0[r]*porportion/spiregulator;
                var ty =  spirray1[r]/spiregulator;
//if (r == 0) console.log(tx);
//	if(!(isFinite(tx) || isFinite(ty) || Math.abs(tx)>window.innerWidth/2 || Math.abs(cy)>window.innerHeight/2))

		if (isFinite(tx)&&isFinite(ty)) point.vertices.push(
 new THREE.Vector3( tx, ty, -0.07 )
);

	}	 

 var line = new THREE.Line( point, lineMat );
			var	scene = new THREE.Scene();
				             scene.add(line);

			if (zoom>.000001&&progress&& reset<1)zoom /= 1.044+Math.abs(totalAMP/bufferSize*2.)/11.;
                else if(zoom<1.)zoom *= 1.044;
      uniforms.coords.value.x = coordX;
      uniforms.coords.value.y = coordY;
      				//uniforms[ "time" ].value = timestamp / 1000;
      uniforms[ "time" ].value = zoom;

      uniforms[ "time2dance" ].value += Math.abs(totalAMP/bufferSize*2.);

				requestAnimationFrame( animate );
if (micOn)analyser.getByteFrequencyData(  dataArray); 


    var maxTestar=0.;
 if(onO){
     for (var g=0; g<starArms; g++) if(testar[g]>maxTestar){maxTestar=testar[g];}
     for (var g=0; g<starArms; g++)if(testar[g]>.0000000000001) {
         var widt = .02;
         var r =(testarD[g]+17)%24./24.*pi*2.;
         var lengt = testar[g]/maxTestar;
         var vo = new THREE.Color();
         b = vo.setHSL((4-testarD[g])%24./24.,1.,.5);
                       material  = new THREE.MeshBasicMaterial( { color:vo});
     meshes[g] = new THREE.Mesh(geometries[g] , material );
     scene.add(meshes[g])
             rpio2 =r+pi/2.;
     var vertices = new Float32Array( [
         0-widt*-Math.sin(rpio2)*porportion,    0-widt*-Math.cos(rpio2),  -0.05,
         0+widt*-Math.sin(rpio2)*porportion,    0+widt*-Math.cos(rpio2),  -0.05,
         (lengt*-Math.sin(r)+widt*-Math.sin(rpio2))*porportion,
         lengt*-Math.cos(r)+widt*-Math.cos(rpio2),  -0.05,
         0-widt*-Math.sin(rpio2)*porportion,    0-widt*-Math.cos(rpio2),  -0.05,
         (lengt*-Math.sin(r)+widt*-Math.sin(rpio2))*porportion,
         lengt*-Math.cos(r)+widt*-Math.cos(rpio2),  -0.05,
         (lengt*-Math.sin(r)-widt*-Math.sin(rpio2))*porportion,
         lengt*-Math.cos(r)-widt*-Math.cos(rpio2),  -0.05,
     ] );

     // itemSize = 3 because there are 3 values (components) per vertex
     geometries[g].addAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );

         }
 }
 else{
             var maxTestar=1.;
             for (var g=0; g<24; g++) if(testar[g]>maxTestar){maxTestar=testar[g];}
             
             for (var g=0; g<24; g++) {
             var widt = .02;
             var r = (g+14)%24;
             var lengt = 1.*testar[(r+7)%24]/maxTestar;

                 var vo = new THREE.Color();
                             b = vo.setHSL((20-r)%24/24.,1.,.5);
                         material  = new THREE.MeshBasicMaterial( { color:vo});
             meshes[r] = new THREE.Mesh(geometries[r] , material );
             scene.add(meshes[r])
             var vertices = new Float32Array( [
                 0-widt*-Math.sin(r*pi*2./24+pi/2.)*porportion,    0-widt*-Math.cos(r*pi*2./24+pi/2.),  -0.05,
                 0+widt*-Math.sin(r*pi*2./24+pi/2.)*porportion,    0+widt*-Math.cos(r*pi*2./24+pi/2.),  -0.05,
                 (lengt*-Math.sin(r*pi*2./24)+widt*-Math.sin(r*pi*2./24+pi/2.))*porportion,
                 lengt*-Math.cos(r*pi*2./24)+widt*-Math.cos(r*pi*2./24+pi/2.),  -0.05,
                 0-widt*-Math.sin(r*pi*2./24+pi/2.)*porportion,    0-widt*-Math.cos(r*pi*2./24+pi/2.),  -0.05,
                 (lengt*-Math.sin(r*pi*2./24)+widt*-Math.sin(r*pi*2./24+pi/2.))*porportion,
                 lengt*-Math.cos(r*pi*2./24)+widt*-Math.cos(r*pi*2./24+pi/2.),  -0.05,
                 (lengt*-Math.sin(r*pi*2./24)-widt*-Math.sin(r*pi*2./24+pi/2.))*porportion,
                 lengt*-Math.cos(r*pi*2./24)-widt*-Math.cos(r*pi*2./24+pi/2.),  -0.05,
             ] );

             // itemSize = 3 because there are 3 values (components) per vertex
             geometries[r].addAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
                 } }
                                                      

var r = (f+trailDepth-2)%trailDepth;
var s = (f+trailDepth-1)%trailDepth;
var loopLimit = trailDepth;
//if(isFinite(cx[r-1])&&isFinite(cx[s])&&isFinite(cy[r-1])&&isFinite(cy[s]))
while(loopLimit>15)
 {loopLimit--;

material = pitchCol[r];
trailMeshes[r] = new THREE.Mesh(trailGeom[r] , material );

 //material = new THREE.LineBasicMaterial( { color: 0x0000ff } );
 //trailMeshes[s] = new THREE.Mesh(trailGeom[s] , material );
// create a simple square shape. We duplicate the top left and bottom right
// vertices because each vertex needs to appear once per triangle.
var widtr = .2*(trailDepth-loopLimit)/trailDepth;
var widts = .2*(trailDepth-loopLimit-1)/trailDepth;
var scalar = .005;//mobius mode: var scalar = .07*loopLimit/trailDepth;
var tt = 0.;
var vertices = new Float32Array( [
(scalar*cx[r]+widtr*xPerp[r])*porportion, scalar*cy[r]+widtr*yPerp[r],-.1,
		                            ( scalar*cx[s]-widts*xPerp[s])*porportion, scalar*cy[s]-widts*yPerp[s],-.1,
				(scalar*cx[s]+widts*xPerp[s])*porportion, scalar*cy[s]+widts*yPerp[s],-.1,
						         ( scalar*cx[r]-widtr*xPerp[r])*porportion, scalar*cy[r]-widtr*yPerp[r],-.1, //2
								                       (scalar*cx[s]-widts*xPerp[s])*porportion, scalar*cy[s]-widts*yPerp[s],-.1,  //1
		                            					(scalar*cx[r]+widtr*xPerp[r])*porportion, scalar*cy[r]+widtr*yPerp[r],-.1, //3
		                            					

] );

trailGeom[r].addAttribute( 'position', new THREE.Float32BufferAttribute( vertices,3 ) );
	scene.add(trailMeshes[r])
	s = r;
	r--;
	
	if(r<=0)r=trailDepth-1;

}


		 mesh = new THREE.Mesh( geometry, materialShader );
				scene.add( mesh );
				renderer.render( scene, camera );
			  // scene1.add( scene );

			scene.dispose();
									point.dispose();
for (var r=0; r<24; r++) geometries[r].dispose();
for (var r=0; r<trailDepth; r++){ trailGeom[r].dispose();}
			}

			
 var audioX;
var micOn = false;
async function startMic() {
  let stream = null;



    stream = await navigator.mediaDevices.getUserMedia({audio: true}).then(

 function (stream){
 micOn = true;
       audioX = new AudioContext();
      analyser = audioX.createAnalyser();
      source = audioX.createMediaStreamSource( stream );
      source.connect(analyser);
      analyser.fftSize = 2048.;
      bufferLength = analyser.frequencyBinCount;
      dataArray = new Uint8Array( bufferLength );
      init();
}
);	
}

    //begin MIT license
    /** Full YIN algorithm */
    function calculatePitch () 
    {
  var yinData = Array(bufferSize/2);
        var period;
        var delta = 0.0, runningSum = 0.0;
        yinData[0] = 1.0;
        for (var tau = 1; tau < yinData.length; tau++)
        {

            yinData[tau] = 0.0;
            for (var j = 0; j < yinData.length; j++)
            {
                delta = inputData[j] - inputData[j + tau];            
               if(isFinite(delta)) yinData[tau] += (delta * delta);
            }
            runningSum += yinData[tau];
            if (runningSum != 0)
            {
                yinData[tau] *= tau / runningSum;
            }
            else
            {
                yinData[tau] = 1.0;
            }
            period = tau - 3;


            if (tau > 4 && (yinData[period] < tolerance) &&
                    (yinData[period] < yinData[period + 1]))
            {
               return quadraticPeakPosition (yinData, period);
            }
        }
        return quadraticPeakPosition (yinData, minElement(yinData));
    }

 


    var tolerance=.3; //, confidence;
    var sampleRate=44100;
   function minElement (d) 
    {

        var j, pos = 0;
        var tmp = d[0];
        for (j = 0; j < bufferSize; j++)
        {
            pos = (tmp < d[j]) ? pos : j;
            tmp = (tmp < d[j]) ? tmp : d[j];
        }
  
        return pos;
    }    

    function quadraticPeakPosition (d, pos) 
    {
    
        var s0, s1, s2;
        var x0, x2;
        if (pos == 0 || pos == bufferSize - 1) return pos;
        x0 = (pos < 1) ? pos : pos - 1;
        x2 = (pos + 1 < bufferSize) ? pos + 1 : pos;
        if (x0 == pos) return (d[pos] <= d[x2]) ? pos : x2;
        if (x2 == pos) return (d[pos] <= d[x0]) ? pos : x0;
        s0 = d[x0];
        s1 = d[pos];
        s2 = d[x2];
        return pos + 0.5 * (s0 - s2 ) / (s0 - 2.* s1 + s2);
    }
//end MIT license
      




	</script>

	</body>
</html>
