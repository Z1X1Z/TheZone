<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Zone:X - Sonic Starship</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <link type="text/css" rel="stylesheet" href="main.css">
    </head>
    <body>
        
        
        <script src="OFFLINEonlineSwitch.js"></script>
        

<!--
https://www.w3schools.com/jsref/tryit.asp?filename=tryjsref_text_create
-->
<script>
function hk() {
  var x = document.createElement("INPUT");
  x.setAttribute("type", "text");
  x.setAttribute("id", "hotkeys");
  x.setAttribute("placeholder", "Hotkeys!");
  x.setAttribute("oninput", "getKey()");
  document.body.appendChild(x);
}


if(navigator.userAgent.toLowerCase().match(/mobile/i)||navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1)
    hk();

let androidGetKey="";
let androidGetKeyLast;

function getKey(){
    androidGetKeyLast = androidGetKey;
    androidGetKey = document.getElementById("hotkeys").value;
 let scan=androidGetKey.length-1;
 if(androidGetKey.length-1==androidGetKeyLast.length) while(androidGetKey[scan]==androidGetKeyLast[scan]&&scan>=0)scan--;
 window.key=androidGetKey[scan];
 }
</script>


        <div id="container"></div>

        <script src="starshipMod.js"></script>
            <script src="wadLoader.js"></script>
            
        <script id="vertexShader" type="x-shader/x-vertex">

                varying vec2 vUv;
                uniform vec2 coords;
                   uniform vec2 resolution;
                   uniform float time;
                   


            void main()    {

                vUv = uv;
                gl_Position = vec4( position, 1.0 );
            }
        </script>

        <script id="fragmentShader" type="x-shader/x-fragment">

            varying vec2 vUv;
            uniform vec2 coords;
               uniform vec2 resolution;
            uniform int colorCombo;
            uniform float time;
            uniform float zoom;
            uniform float metronome;

            uniform float time2dance;
            uniform int fourCreats;

            
            uniform bool MetaCored;
            uniform bool free;
            float zin(float x){return -sin(x);}
            float coz(float x){return -cos(x);}

          vec3 heart(vec2 g, vec2 t){
              g.x-=.5;
              g.y*=-1.;
              vec2 z=g.xy;
          vec3 h=vec3(0.);
              for (int f=0;f<60;f+=1)if(abs(z.y+z.x)>2.)h=vec3(0.);
              else {z=vec2(((z.x*z.x-z.y*z.y)-g.x+t.x),(2.0*z.x*z.y-g.y+t.y*4.));//mandelbrot loop factored into real and imaginary components from z<=z^2-g
                h+=vec3(z.x*z.y,z.x,z.y)/21.;}
          return h;
          }
              vec3 face(vec2 g, vec2 t){
              float l = 1.;
              g*=2.;
              vec2 z=g.xy;
              if(g.x*g.x+g.y*g.y<40.)for (int f=0;f<21;f+=1)if(abs(z.y)>19.&&(f==1||f>3)){
                  if (f==1){l=1.;break;}
                  l=1.-length(z)/40.;//clouds and face
                  break;}
              else{
                  z=vec2(-1./(z.x*z.x-z.y*z.y-g.x),2.0*z.x*z.y-g.y);
                  l=abs(z.y)*6.;//smooths middle horn, removes some clouds
                  if(z.x>-.1)l=z.x*50.;}//face with closed small holes
              return vec3(clamp(1.-l,0.,1.));
              }

         vec3 shiny(vec2 p,vec2 t){
            p*=2.;
             vec2 s = p;
             float l=0., d = 0., negator = 1.;
                 for (int f=0;f<21;f+=1)
                 if(abs(s.y)>21.&&(f==1||f>2)){
                     l=1.-length(s)/40.;
                     if (f == 1)
                             negator=0.;
                     else
                             d+=length(s)/10.;
                     break;
                 }
                 else{
                     s=vec2(-1./(s.x*s.x-s.y*s.y-p.x), 2.0*s.x*s.y-p.y);
                     l=abs(s.y)*3.5;//refines middle horn, optional
                     if(s.x>-.1)l=s.x*50.;//closes small holes
                     d+=length(s)/10.;
                 }
                 if (l>.54) negator = 0.;
                 return vec3(-sin(d +t.x*3.+6.28318/3.),-sin(d+t.x*3.+6.28318*5./3.),-sin(d+t.x*3.))*5.*negator;
         }


          vec3 torso(vec2 g, vec2 t){
          float b = 0.;
          vec2 z=g.xy;
          if(g.x*g.x+g.y*g.y<40.)if (g.x>0.)for(int f=0;f<12;f+=1)if(abs(z.y)>52.&&f>4)b=abs(z.y)/77.;
          else{
              z=2.*vec2(-1./(z.x*z.x-z.y*z.y-g.x),(2.0*z.x*z.y-g.y+t.y));
              z.x=sqrt(abs(z.x));}
          return vec3(b,b/2.5,0.);
          }
          vec3 musculature(vec2 g, vec2 t){
          float m=0.;
          g.x+=.54;
          vec2 z=g.xy;
          if(g.x>1.25&&abs(g.y)<2.5)for(int f=0;f<15;f+=1)if(abs(z.y)>15.&&f>7&&f!=15)m=abs(z.y)/25.;
          else {
              z=1.3*vec2(-1.5/((z.x*z.x-2.*z.y*z.y)-g.x),(1.9*z.x*z.y-1.87*g.y+t.y/4.));
              z.x=pow(abs(z.x),.57);}
          return vec3(m,m,m/2.);
          }
          vec3 robe(vec2 g, vec2 t){
          float r=0.;
          g.x+=.05;
          g.y/=1.14;
          vec2 z=g.xy;
          if(g.x>.5 &&abs(g.y)<1.)for(int f=0;f<70;f+=1)if(abs(z.y)>11.&&f>7)r=clamp(1.4-abs(g.x-2.3)
                           //*(1.-abs(g.y*g.x))-.07//(un)comment this line to toggle sleeves
                          ,0.,1.);
          else{
              z=1.1*vec2(-2./((z.x*z.x-1.8*z.y*z.y)-g.x),(3.*z.x*z.y-1.3*g.y+t.y));;
              z.x=pow(abs(z.x),.8);}
          return vec3(r);
          }
          vec3 legs(vec2 g, vec2 t){
          float b=0.;
          g/=2.;
          vec2 z=g.xy;
          if(g.x>.75&&g.x<1.7&&abs(g.y*g.x)<.54)for(int f=0;f<8;f+=1)if(abs(z.x)>52.&&f>1)b=abs(z.x)/70.;
          else{
              z=3.*vec2(-1./(z.x*z.x-z.y*z.y-g.x),77.*z.x*z.y-g.y+t.y);
              z.y=-1./z.y;}
          return vec3(b/2.,b,b/2.);
          }
                        vec2 freed(vec2 p){
                            if(free){
                                float shift = 3.;
                                p+=shift/2.;
                                p=(mod(abs(p),shift));
                                p-=shift/2.;
                            }
                            return p;
                            }
                        
    vec3 tol(vec2 p, vec2 t){
        float cored = log(zoom*3./2.)/log(.5)+1.;
        float c = length(p);
        int loops=1;
        if(MetaCored)for(int i=1;i<144; i++)if(c<2./3.&&float(loops)<cored){p*=2.;c*=2.;loops++;}else break;
        vec2 s=p;
        loops=0;
        int hyperCore= int(cored*2./3.+log(length(freed(coords))*3./2.)-1.);
        for (int counter=0;counter<41;counter+=1)if(abs(s.y)<47.){
          
          
          s=vec2(s.x*s.x*s.x  - 3.*s.x*s.y*s.y+t.x, -s.y*s.y*s.y+ 3.*s.x*s.x*s.y+t.y);//x**3
          s.x=log(abs(s.x));
          
            if(MetaCored){
                float d = length(s);

                for(int i=0;i<69; i++)if(d<2./3.&& loops+counter<hyperCore)
         {float shift=2.;s*=shift;d*=shift;loops++;}
                
                    else break;
            }
        }

                                 
                                 vec3 o=vec3(s.y);
        if(colorCombo==1) o=vec3(s.y,s.x/10.,1.-s.x/12.);
        else if(colorCombo==2) o=vec3(s.y/100.,s.x/8.-s.y/s.x/7000.,1.-s.x/16.)/1.2;
        else if(colorCombo==3) o=vec3(s.y/100.-s.x*s.y/888.,s.x/8.-s.y/s.x/2000.,1.-s.x/20.);
        else if(colorCombo==4) o= vec3(1.-s.x/20.,s.x/8.-s.y/s.x/2000.,s.y/35.-s.x*s.y/888.);
        else if(colorCombo==5)  o=vec3(s.y/40.-s.x*s.y/888.,1.-s.x/21.,s.x/6.-s.y/s.x/2000.);
        else if(colorCombo==6)o= vec3(s.x/8.-s.y/s.x/7000.,1.-s.x/16.,s.y/100.)/1.1;
                                    else if(colorCombo==7) return vec3(-sin(time*1.)*s.y/100.-sin(time*1.618)*s.x*s.y/888.,s.x/8.-sin(time*-.618)*s.y/s.x/2000.,1.-sin(time*2.618)*s.x/20.);
                                    

        return clamp(o,0.,1.);}
                                           

 
          vec3 body(vec2 p, vec2 t){return torso(p,t)+musculature(p,t)+robe(p,t)+legs(p,t);}
          vec3 bod(vec2 p, vec2 t){t*=zoom;return body(p,t)+heart(p,t);}
          vec3 manny(vec2 p, vec2 t){return body(p,t)+heart(p,t)+face(p,vec2(time,0.))*1.4+shiny(p,vec2(time,0.))/9.;}

          //function library: manny body legs robe musculature torso face excelsior shiny lion ox man eagle eaglePerched fourCreatures heart anomalyze spin
          void main(){
           vec2 p=-((vUv.yx)-.5)/(resolution.xy/min(resolution.x,resolution.y))*12.;
           vec2 bg =p/2.;
              p.x+=.5;

          float rate = 7.;
          vec2 t =vec2(-sin(rate*time2dance)/50.,-sin(time2dance*(rate*1.618)*3.)/30.);
          vec3 zoomer=tol(freed(bg*zoom+coords.yx),vec2(0.));
          vec3 mny=manny(p,t);
          gl_FragColor=vec4(mny+
                            clamp(zoomer-(mny.r+mny.b+mny.g)*100.,.0,1.)
                    ,1.);}
        </script>
    </body>
</html>
